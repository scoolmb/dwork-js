/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { D_WORK_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const INITIALIZE_JOB_DISCRIMINATOR = new Uint8Array([
  137, 22, 138, 41, 76, 208, 114, 50,
]);

export function getInitializeJobDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INITIALIZE_JOB_DISCRIMINATOR
  );
}

export type InitializeJobInstruction<
  TProgram extends string = typeof D_WORK_PROGRAM_ADDRESS,
  TAccountEmployer extends string | AccountMeta<string> = string,
  TAccountJob extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountDelegate extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountEmployer extends string
        ? WritableSignerAccount<TAccountEmployer> &
            AccountSignerMeta<TAccountEmployer>
        : TAccountEmployer,
      TAccountJob extends string ? WritableAccount<TAccountJob> : TAccountJob,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountDelegate extends string
        ? ReadonlyAccount<TAccountDelegate>
        : TAccountDelegate,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type InitializeJobInstructionData = {
  discriminator: ReadonlyUint8Array;
  amount: bigint;
  collateralAmount: Option<bigint>;
  confirmationDuration: Option<bigint>;
};

export type InitializeJobInstructionDataArgs = {
  amount: number | bigint;
  collateralAmount: OptionOrNullable<number | bigint>;
  confirmationDuration: OptionOrNullable<number | bigint>;
};

export function getInitializeJobInstructionDataEncoder(): Encoder<InitializeJobInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['amount', getU64Encoder()],
      ['collateralAmount', getOptionEncoder(getU64Encoder())],
      ['confirmationDuration', getOptionEncoder(getI64Encoder())],
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_JOB_DISCRIMINATOR })
  );
}

export function getInitializeJobInstructionDataDecoder(): Decoder<InitializeJobInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['amount', getU64Decoder()],
    ['collateralAmount', getOptionDecoder(getU64Decoder())],
    ['confirmationDuration', getOptionDecoder(getI64Decoder())],
  ]);
}

export function getInitializeJobInstructionDataCodec(): Codec<
  InitializeJobInstructionDataArgs,
  InitializeJobInstructionData
> {
  return combineCodec(
    getInitializeJobInstructionDataEncoder(),
    getInitializeJobInstructionDataDecoder()
  );
}

export type InitializeJobAsyncInput<
  TAccountEmployer extends string = string,
  TAccountJob extends string = string,
  TAccountVault extends string = string,
  TAccountDelegate extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  employer: TransactionSigner<TAccountEmployer>;
  job?: Address<TAccountJob>;
  vault?: Address<TAccountVault>;
  delegate: Address<TAccountDelegate>;
  systemProgram?: Address<TAccountSystemProgram>;
  amount: InitializeJobInstructionDataArgs['amount'];
  collateralAmount: InitializeJobInstructionDataArgs['collateralAmount'];
  confirmationDuration: InitializeJobInstructionDataArgs['confirmationDuration'];
};

export async function getInitializeJobInstructionAsync<
  TAccountEmployer extends string,
  TAccountJob extends string,
  TAccountVault extends string,
  TAccountDelegate extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof D_WORK_PROGRAM_ADDRESS,
>(
  input: InitializeJobAsyncInput<
    TAccountEmployer,
    TAccountJob,
    TAccountVault,
    TAccountDelegate,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  InitializeJobInstruction<
    TProgramAddress,
    TAccountEmployer,
    TAccountJob,
    TAccountVault,
    TAccountDelegate,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? D_WORK_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    employer: { value: input.employer ?? null, isWritable: true },
    job: { value: input.job ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    delegate: { value: input.delegate ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.job.value) {
    accounts.job.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([106, 111, 98])),
        getAddressEncoder().encode(expectAddress(accounts.employer.value)),
      ],
    });
  }
  if (!accounts.vault.value) {
    accounts.vault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([118, 97, 117, 108, 116])),
        getAddressEncoder().encode(expectAddress(accounts.job.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.employer),
      getAccountMeta(accounts.job),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.delegate),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getInitializeJobInstructionDataEncoder().encode(
      args as InitializeJobInstructionDataArgs
    ),
    programAddress,
  } as InitializeJobInstruction<
    TProgramAddress,
    TAccountEmployer,
    TAccountJob,
    TAccountVault,
    TAccountDelegate,
    TAccountSystemProgram
  >);
}

export type InitializeJobInput<
  TAccountEmployer extends string = string,
  TAccountJob extends string = string,
  TAccountVault extends string = string,
  TAccountDelegate extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  employer: TransactionSigner<TAccountEmployer>;
  job: Address<TAccountJob>;
  vault: Address<TAccountVault>;
  delegate: Address<TAccountDelegate>;
  systemProgram?: Address<TAccountSystemProgram>;
  amount: InitializeJobInstructionDataArgs['amount'];
  collateralAmount: InitializeJobInstructionDataArgs['collateralAmount'];
  confirmationDuration: InitializeJobInstructionDataArgs['confirmationDuration'];
};

export function getInitializeJobInstruction<
  TAccountEmployer extends string,
  TAccountJob extends string,
  TAccountVault extends string,
  TAccountDelegate extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof D_WORK_PROGRAM_ADDRESS,
>(
  input: InitializeJobInput<
    TAccountEmployer,
    TAccountJob,
    TAccountVault,
    TAccountDelegate,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): InitializeJobInstruction<
  TProgramAddress,
  TAccountEmployer,
  TAccountJob,
  TAccountVault,
  TAccountDelegate,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? D_WORK_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    employer: { value: input.employer ?? null, isWritable: true },
    job: { value: input.job ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    delegate: { value: input.delegate ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.employer),
      getAccountMeta(accounts.job),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.delegate),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getInitializeJobInstructionDataEncoder().encode(
      args as InitializeJobInstructionDataArgs
    ),
    programAddress,
  } as InitializeJobInstruction<
    TProgramAddress,
    TAccountEmployer,
    TAccountJob,
    TAccountVault,
    TAccountDelegate,
    TAccountSystemProgram
  >);
}

export type ParsedInitializeJobInstruction<
  TProgram extends string = typeof D_WORK_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    employer: TAccountMetas[0];
    job: TAccountMetas[1];
    vault: TAccountMetas[2];
    delegate: TAccountMetas[3];
    systemProgram: TAccountMetas[4];
  };
  data: InitializeJobInstructionData;
};

export function parseInitializeJobInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedInitializeJobInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 5) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      employer: getNextAccount(),
      job: getNextAccount(),
      vault: getNextAccount(),
      delegate: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getInitializeJobInstructionDataDecoder().decode(instruction.data),
  };
}
